package SP.constructive_heuristics;

import SP.representations.*;
import SP.util.HeuristicUtil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Constructive heuristic to efficiently generate feasible solutions to stacking
 * problems with an arbitrary stack capacity. The goal is to minimize the transport costs
 * while respecting all given constraints.
 * TODO: This is a first naive approach to generate initial solution for the local search.
 *       The costs aren't considered atm (to be refined).
 *
 * @author Tim Bohne
 */
public class GeneralHeuristic {

    private final Instance instance;
    private final double timeLimit;

    /**
     * Constructor
     *
     * @param instance  - instance of the stacking problem to be solved
     * @param timeLimit - time limit for the solving procedure
     */
    public GeneralHeuristic(Instance instance, double timeLimit) {
        this.instance = instance;
        this.timeLimit = timeLimit;
    }

    /**
     * Solves the given instance of the stacking problem.
     *
     * Basic idea:
     *      - shuffle items
     *      - assign items using first-fit
     *      - repeat until feasible
     *
     * @return solution generated by the heuristic
     */
    public Solution solve() {
        Solution sol = new Solution();
        double startTime = System.currentTimeMillis();
        while (!sol.isFeasible()) {
            this.instance.resetStacks();
            this.generateFirstFitSolution();
            this.instance.lowerItemsThatAreStackedInTheAir();
            sol = new Solution((System.currentTimeMillis() - startTime) / 1000.0, this.timeLimit, this.instance);
        }
        sol.sortItemsInStacksBasedOnTransitiveStackingConstraints();
        sol.setTimeToSolve((System.currentTimeMillis() - startTime) / 1000.0);
        return sol;
    }

    /**
     * Generates a list from the given item array.
     *
     * @return item list
     */
    private List<Integer> getItemList() {
        List<Integer> items = new ArrayList<>();
        for (int item : this.instance.getItems()) {
            items.add(item);
        }
        return items;
    }

    /**
     * Assigns the items to the stacks of the given instance using a naive first-fit approach.
     */
    private void generateFirstFitSolution() {

        List<Integer> itemList = this.getItemList();
        Collections.shuffle(itemList);

        for (int item : itemList) {
            for (int stack = 0; stack < this.instance.getStacks().length; stack++) {
                if (HeuristicUtil.itemCompatibleWithStack(this.instance.getCosts(), item, stack)
                    && HeuristicUtil.stackHasFreePosition(this.instance.getStacks()[stack])
                    && HeuristicUtil.itemCompatibleWithAlreadyAssignedItems(
                        item, this.instance.getStacks()[stack], this.instance.getItemObjects(), this.instance.getStackingConstraints()
                    )
                ) {
                    HeuristicUtil.assignItemToStack(
                        item, this.instance.getStacks()[stack], this.instance.getItemObjects()
                    );
                    break;
                }
            }
        }
    }
}
