package SP.post_optimization_methods;

import SP.experiments.PostOptimization;
import SP.representations.Solution;

/**
 * Improvement heuristic that starts with an initial solution of a stacking-problem
 * and tries to improve its quality in terms of cost minimization by performing a tabu-search.
 *
 * @author Tim Bohne
 */
public class TabuSearch {

    private Solution currSol;
    private Solution bestSol;
    private double timeLimit;
    private double startTime;
    private final double optimalObjectiveValue;

    private final PostOptimization.ShortTermStrategies shortTermStrategy;
    private final PostOptimization.StoppingCriteria stoppingCriterion;
    private final int numberOfNeighbors;

    private final int maxTabuListLength;
    private final int unsuccessfulNeighborGenerationAttempts;

    private int iterationOfLastImprovement;
    private final int numberOfNonImprovingIterations;
    private final int numberOfIterations;
    private final int numberOfTabuListClears;

    /**
     * Constructor
     *
     * @param initialSolution                        - initial solution to be improved
     * @param timeLimit                              - time limit for the improvement procedure
     * @param optimalObjectiveValue                  - optimal objective value for the solution (generated by CPLEX)
     * @param numberOfNeighbors                      - number of neighbors considered in short-term strategy
     * @param maxTabuListLengthFactor                - factor used to compute max length of tabu list
     * @param shortTermStrategy                      - strategy for neighborhood exploration
     * @param unsuccessfulNeighborGenerationAttempts - number of unsuccessful neighbor generation attempts before TL reset
     * @param numberOfNonImprovingIterations         - number of non improving iterations before termination
     * @param numberOfIterations                     - number of iterations before termination
     * @param numberOfTabuListClears                 - number of tabu list clears before termination
     * @param stoppingCriterion                      - stopping criterion to be used
     */
    public TabuSearch(
        Solution initialSolution, double timeLimit, double optimalObjectiveValue, int numberOfNeighbors,
        int maxTabuListLengthFactor, PostOptimization.ShortTermStrategies shortTermStrategy,
        int unsuccessfulNeighborGenerationAttempts, int numberOfNonImprovingIterations, int numberOfIterations,
        int numberOfTabuListClears, PostOptimization.StoppingCriteria stoppingCriterion
    ) {
        this.currSol = new Solution(initialSolution);
        this.bestSol = new Solution(initialSolution);
        this.iterationOfLastImprovement = 0;

        this.numberOfNeighbors = numberOfNeighbors;
        this.shortTermStrategy = shortTermStrategy;
        this.stoppingCriterion = stoppingCriterion;
        this.unsuccessfulNeighborGenerationAttempts = unsuccessfulNeighborGenerationAttempts;
        this.numberOfNonImprovingIterations = numberOfNonImprovingIterations;

        this.numberOfIterations = numberOfIterations;
        this.numberOfTabuListClears = numberOfTabuListClears;

        this.maxTabuListLength = this.numberOfNeighbors * maxTabuListLengthFactor;
        this.startTime = System.currentTimeMillis();
        this.timeLimit = 0;
        this.optimalObjectiveValue = optimalObjectiveValue;
        this.timeLimit = timeLimit;
    }

    /**
     * Improves a given solution to a stacking problem using a tabu search.
     *
     * @return best solution generated in the tabu search procedure
     */
    public Solution solve() {

        this.startTime = System.currentTimeMillis();

        Neighborhood neighborhood = new EjectionChainsNeighborhood(
            this.numberOfNeighbors, this.shortTermStrategy, this.maxTabuListLength,
            this.unsuccessfulNeighborGenerationAttempts
        );

        switch (this.stoppingCriterion) {
            case ITERATIONS:
                this.solveIterations(neighborhood);
                break;
            case TABU_LIST_CLEARS:
                this.solveTabuListClears(neighborhood);
                break;
            case NON_IMPROVING_ITERATIONS:
                this.solveIterationsSinceLastImprovement(neighborhood);
                break;
            default:
                this.solveIterationsSinceLastImprovement(neighborhood);
        }
        return this.bestSol;
    }

    /**
     * Retrieves a neighboring solution by applying the operators with certain probabilities.
     *
     * @return neighboring solution
     */
    private Solution getNeighborBasedOnProbabilities(Neighborhood neighborhood) {
        Solution sol = neighborhood.getNeighbor(this.currSol, this.bestSol);
        return sol == null ? this.currSol : sol;
    }

//    /**
//     * Applies the combined shift- and swap-neighborhood to retrieve the best neighbor.
//     *
//     * @return best generated neighbor
//     */
//    private Solution getNeighbor() {
//        List<Solution> nbrs = new ArrayList<>();
//        // shift is only possible if there are free slots
//        if (this.currSol.getNumberOfAssignedItems() < this.currSol.getFilledStacks().length * this.currSol.getFilledStacks()[0].length) {
//            nbrs.add(this.getNeighborShift());
//        }
//        nbrs.add(this.getNeighborKSwap(1));
//        nbrs.add(this.getNeighborKSwap(HeuristicUtil.getRandomIntegerInBetween(2, this.kSwapIntervalUB)));
//
//        return Collections.min(nbrs);
//    }

    /**
     * Updates the current solution with the best neighbor.
     * Additionally, the best solution gets updated if a new best solution is found.
     *
     * @param iteration - current iteration
     */
    private void updateCurrentSolution(int iteration, Neighborhood neighborhood) {
        this.currSol = this.getNeighborBasedOnProbabilities(neighborhood);
        if (this.currSol.computeCosts() < this.bestSol.computeCosts()) {
            this.bestSol = this.currSol;
            this.iterationOfLastImprovement = iteration;
        }
    }

    /**
     * Performs the tabu search with a number of iterations as stop criterion.
     */
    private void solveIterations(Neighborhood neighborhood) {
        for (int i = 0; i < this.numberOfIterations; i++) {
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(i, neighborhood);
        }
    }

    /**
     * Performs the tabu search with a number of tabu list clears as stop criterion.
     */
    private void solveTabuListClears(Neighborhood neighborhood) {
        int iteration = 0;
        while (neighborhood.getTabuListClears() < this.numberOfTabuListClears) {
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(iteration++, neighborhood);
        }
    }

    /**
     * Performs the tabu search with a number of non-improving iterations as stop criterion.
     */
    private void solveIterationsSinceLastImprovement(Neighborhood neighborhood) {
        int iteration = 0;
        while (Math.abs(this.iterationOfLastImprovement - iteration) < this.numberOfNonImprovingIterations) {
            System.out.println("non improving iterations: " + Math.abs(this.iterationOfLastImprovement - iteration));
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(iteration++, neighborhood);
        }
    }
}


