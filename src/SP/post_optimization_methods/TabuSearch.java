package SP.post_optimization_methods;

import SP.experiments.PostOptimization;
import SP.representations.Solution;
import SP.util.HeuristicUtil;

/**
 * Improvement heuristic that starts with an initial solution of a stacking-problem
 * and tries to improve its quality in terms of cost minimization by performing a tabu-search.
 *
 * @author Tim Bohne
 */
public class TabuSearch {

    private Solution currSol;
    private Solution bestSol;
    private double timeLimit;
    private double startTime;
    private final double optimalObjectiveValue;

    private final PostOptimization.ShortTermStrategies shortTermStrategy;
    private final PostOptimization.StoppingCriteria stoppingCriterion;
    private final int numberOfNeighbors;

    private final int maxTabuListLength;
    private final int unsuccessfulNeighborGenerationAttempts;
    private final int unsuccessfulKSwapAttempts;
    private final int kSwapIntervalUB;
    private final float kSwapProbability;
    private final float swapProbability;

    private int iterationOfLastImprovement;
    private final int numberOfNonImprovingIterations;
    private final int numberOfIterations;
    private final int numberOfTabuListClears;

    /**
     * Constructor
     *
     * @param initialSolution                        - initial solution to be improved
     * @param timeLimit                              - time limit for the improvement procedure
     * @param optimalObjectiveValue                  - optimal objective value for the solution (generated by CPLEX)
     * @param numberOfNeighbors                      - number of neighbors considered in short-term strategy
     * @param maxTabuListLengthFactor                - factor used to compute max length of tabu list
     * @param shortTermStrategy                      - strategy for neighborhood exploration
     * @param unsuccessfulNeighborGenerationAttempts - number of unsuccessful neighbor generation attempts before TL reset
     * @param unsuccessfulKSwapAttempts              - number of unsuccessful k swap attempts before skip
     * @param numberOfNonImprovingIterations         - number of non improving iterations before termination
     * @param kSwapIntervalUB                        - upper bound for interval of k-swap
     * @param numberOfIterations                     - number of iterations before termination
     * @param numberOfTabuListClears                 - number of tabu list clears before termination
     * @param stoppingCriterion                      - stopping criterion to be used
     */
    public TabuSearch(
        Solution initialSolution, double timeLimit, double optimalObjectiveValue, int numberOfNeighbors,
        int maxTabuListLengthFactor, PostOptimization.ShortTermStrategies shortTermStrategy,
        int unsuccessfulNeighborGenerationAttempts, int unsuccessfulKSwapAttempts, int numberOfNonImprovingIterations,
        int kSwapIntervalUB, int numberOfIterations, int numberOfTabuListClears,
        PostOptimization.StoppingCriteria stoppingCriterion, float kSwapProbability, float swapProbability
    ) {
        this(
            initialSolution, optimalObjectiveValue, numberOfNeighbors, maxTabuListLengthFactor, shortTermStrategy,
            unsuccessfulNeighborGenerationAttempts, unsuccessfulKSwapAttempts, numberOfNonImprovingIterations,
            kSwapIntervalUB, numberOfIterations, numberOfTabuListClears, stoppingCriterion, kSwapProbability, swapProbability
        );
        this.timeLimit = timeLimit;
    }

    /**
     * Constructor
     *
     * @param initialSolution                        - initial solution to be improved
     * @param optimalObjectiveValue                  - optimal objective value for the solution (generated by CPLEX)
     * @param numberOfNeighbors                      - number of neighbors considered in short-term strategy
     * @param maxTabuListLengthFactor                - factor used to compute max length of tabu list
     * @param shortTermStrategy                      - strategy for neighborhood exploration
     * @param unsuccessfulNeighborGenerationAttempts - number of unsuccessful neighbor generation attempts before TL reset
     * @param unsuccessfulKSwapAttempts              - number of unsuccessful k swap attempts before skip
     * @param numberOfNonImprovingIterations         - number of non improving iterations before termination
     * @param kSwapIntervalUB                        - upper bound for interval of k-swap
     * @param numberOfIterations                     - number of iterations before termination
     * @param numberOfTabuListClears                 - number of tabu list clears before termination
     * @param stoppingCriterion                      - stopping criterion to be used
     * @param kSwapProbability                       - probability for applying the k-swap operator
     * @param swapProbability                        - probability for applying the swap operator
     */
    public TabuSearch(
        Solution initialSolution, double optimalObjectiveValue, int numberOfNeighbors, int maxTabuListLengthFactor,
        PostOptimization.ShortTermStrategies shortTermStrategy, int unsuccessfulNeighborGenerationAttempts,
        int unsuccessfulKSwapAttempts, int numberOfNonImprovingIterations, int kSwapIntervalUB, int numberOfIterations,
        int numberOfTabuListClears, PostOptimization.StoppingCriteria stoppingCriterion, float kSwapProbability, float swapProbability
    ) {
        this.currSol = new Solution(initialSolution);
        this.bestSol = new Solution(initialSolution);
        this.iterationOfLastImprovement = 0;

        this.numberOfNeighbors = numberOfNeighbors;
        this.shortTermStrategy = shortTermStrategy;
        this.stoppingCriterion = stoppingCriterion;
        this.unsuccessfulNeighborGenerationAttempts = unsuccessfulNeighborGenerationAttempts;
        this.unsuccessfulKSwapAttempts = unsuccessfulKSwapAttempts;
        this.numberOfNonImprovingIterations = numberOfNonImprovingIterations;

        this.kSwapIntervalUB = kSwapIntervalUB;
        this.kSwapProbability = kSwapProbability;
        this.swapProbability = swapProbability;

        this.numberOfIterations = numberOfIterations;
        this.numberOfTabuListClears = numberOfTabuListClears;

        this.maxTabuListLength = this.numberOfNeighbors * maxTabuListLengthFactor;
        this.startTime = System.currentTimeMillis();
        this.timeLimit = 0;
        this.optimalObjectiveValue = optimalObjectiveValue;
    }

    /**
     * Improves a given solution to a stacking problem using a tabu search.
     *
     * @return best solution generated in the tabu search procedure
     */
    public Solution solve() {

        this.startTime = System.currentTimeMillis();

        // TODO: add other nbh

//        StackBasedSwapShiftNeighborhood neighborhood = new StackBasedSwapShiftNeighborhood(
//            this.numberOfNeighbors, this.shortTermStrategy, this.maxTabuListLength,
//            this.unsuccessfulNeighborGenerationAttempts, this.unsuccessfulKSwapAttempts
//        );

        PartitionBasedSwapShiftNeighborhood neighborhood = new PartitionBasedSwapShiftNeighborhood(
            this.numberOfNeighbors, this.shortTermStrategy, this.maxTabuListLength,
            this.unsuccessfulNeighborGenerationAttempts, this.unsuccessfulKSwapAttempts
        );

        switch (this.stoppingCriterion) {
            case ITERATIONS:
                this.solveIterations(neighborhood);
                break;
            case TABU_LIST_CLEARS:
                this.solveTabuListClears(neighborhood);
                break;
            case NON_IMPROVING_ITERATIONS:
                this.solveIterationsSinceLastImprovement(neighborhood);
                break;
            default:
                this.solveIterationsSinceLastImprovement(neighborhood);
        }
        return this.bestSol;
    }

    /**
     * Retrieves a neighboring solution by applying the operators with certain probabilities.
     *
     * @return neighboring solution
     */
    private Solution getNeighborBasedOnProbabilities(PartitionBasedSwapShiftNeighborhood neighborhood) {

        double rand = Math.random();
        Solution sol;

        if (rand < this.kSwapProbability / 100.0) {
            sol = neighborhood.getNeighborKSwap(HeuristicUtil.getRandomIntegerInBetween(2, this.kSwapIntervalUB),
                    this.currSol, this.bestSol);
        } else if (rand < (this.swapProbability + this.kSwapProbability) / 100.0) {
            sol =  neighborhood.getNeighborKSwap(1, this.currSol, this.bestSol);
        } else {
            // shift is only possible if there are free slots
            if (this.currSol.getNumberOfAssignedItems() < this.currSol.getFilledStacks().length * this.currSol.getFilledStacks()[0].length) {
                sol = neighborhood.getNeighborShift(this.currSol, this.bestSol);
            } else {
                sol =  neighborhood.getNeighborKSwap(1, this.currSol, this.bestSol);
            }
        }
        if (sol == null) {
            return this.currSol;
        }
        return sol;
    }

//    /**
//     * Applies the combined shift- and swap-neighborhood to retrieve the best neighbor.
//     *
//     * @return best generated neighbor
//     */
//    private Solution getNeighbor() {
//        List<Solution> nbrs = new ArrayList<>();
//        // shift is only possible if there are free slots
//        if (this.currSol.getNumberOfAssignedItems() < this.currSol.getFilledStacks().length * this.currSol.getFilledStacks()[0].length) {
//            nbrs.add(this.getNeighborShift());
//        }
//        nbrs.add(this.getNeighborKSwap(1));
//        nbrs.add(this.getNeighborKSwap(HeuristicUtil.getRandomIntegerInBetween(2, this.kSwapIntervalUB)));
//
//        return Collections.min(nbrs);
//    }

    /**
     * Updates the current solution with the best neighbor.
     * Additionally, the best solution gets updated if a new best solution is found.
     *
     * @param iteration - current iteration
     */
    private void updateCurrentSolution(int iteration, PartitionBasedSwapShiftNeighborhood neighborhood) {
        this.currSol = this.getNeighborBasedOnProbabilities(neighborhood);
        if (this.currSol.computeCosts() < this.bestSol.computeCosts()) {
            this.bestSol = this.currSol;
            this.iterationOfLastImprovement = iteration;
        }
    }

    /**
     * Performs the tabu search with a number of iterations as stop criterion.
     */
    private void solveIterations(PartitionBasedSwapShiftNeighborhood neighborhood) {
        for (int i = 0; i < this.numberOfIterations; i++) {
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(i, neighborhood);
        }
    }

    /**
     * Performs the tabu search with a number of tabu list clears as stop criterion.
     */
    private void solveTabuListClears(PartitionBasedSwapShiftNeighborhood neighborhood) {
        int iteration = 0;
        while (neighborhood.getTabuListClears() < this.numberOfTabuListClears) {
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(iteration++, neighborhood);
        }
    }

    /**
     * Performs the tabu search with a number of non-improving iterations as stop criterion.
     */
    private void solveIterationsSinceLastImprovement(PartitionBasedSwapShiftNeighborhood neighborhood) {
        int iteration = 0;
        while (Math.abs(this.iterationOfLastImprovement - iteration) < this.numberOfNonImprovingIterations) {
            System.out.println("non improving iterations: " + Math.abs(this.iterationOfLastImprovement - iteration));
            if (this.timeLimit != 0 && (System.currentTimeMillis() - this.startTime) / 1000 > this.timeLimit) { break; }
            if (this.bestSol.computeCosts() == this.optimalObjectiveValue) { break; }
            this.updateCurrentSolution(iteration++, neighborhood);
        }
    }
}


